<!DOCTYPE html>
<html lang="en">
  <head>
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="本文量子 PCP 猜想的系列介绍的第一篇, 关于经典和量子交互式证明. 第一部分包括从 NP 开始给出交互式证明的一系列结果, 包括多轮交互式证明, 多个证明者的多伦交互式证明, 以及导出的一系列概率可检测证明 (PCP), 但是不会涉及任何密码学相关的结果. 之后, 解释 PCP 定理中概率可检查证明 (或者说局部可检测证明) 的意义, 以及 PCP 定理的其他表述形式 (与不可近似性的联系. 第二部分包括定义 NP 的量子对应 QMA 及其完全问题, 在此基础上给出量子交互式证明系统相关的复杂性类的一系列定义 (一个证明者是 QIP 和多个证明者是 MIP∗), 以及交互式证明版本的量子 PCP 猜想的定义. 最后介绍近年关于量子 PCP 猜想的几个弱化版本 (即 MIP∗ 的下界) 的结果, 并简要提及与 MIP∗ 的可能上界有关的结果."/>




  <meta name="keywords" content="理论计算机科学, 量子计算理论, Complexity Meets Quantum" />










  <link rel="alternate" href="/atom.xml" title="Complexity Meets Quantum">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=2.6.0" />



<link rel="canonical" href="http://climberpi.github.io/2018/06/22/games-qpcp-interactive-proofs/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZNLTH5PWL2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZNLTH5PWL2');
</script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "nI9TEHVDOnoMEywQ0nzNyJOI-gzGzoHsz",
      appKey: "rvxJbiglsBWMoxSQsvwmwX7d"
    });
  </script>





    <title> 量子 PCP 猜想浅说 (一): 当交互式证明遇上量子纠缠 - Complexity Meets Quantum </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Complexity Meets Quantum</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="/search">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Complexity Meets Quantum</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/search">
            
            
              Search
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          量子 PCP 猜想浅说 (一): 当交互式证明遇上量子纠缠
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-22
        </span>
        
          <div class="post-category">
            
              <a href="/categories/理论计算机科学/">理论计算机科学</a>
            
              <a href="/categories/理论计算机科学/量子计算理论/">量子计算理论</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2018/06/22/games-qpcp-interactive-proofs/"
             data-title="量子 PCP 猜想浅说 (一): 当交互式证明遇上量子纠缠">
            Views
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#交互式证明-从-np-到-pcp-定理"><span class="toc-text"> 交互式证明: 从 NP 到 PCP 定理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#形形色色的交互式证明系统"><span class="toc-text"> 形形色色的交互式证明系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pcp-定理的等价描述"><span class="toc-text"> PCP 定理的等价描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#当交互式证明遇上量子力学"><span class="toc-text"> 当交互式证明遇上量子力学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#量子交互式证明系统"><span class="toc-text"> 量子交互式证明系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当交互式证明遇上量子纠缠"><span class="toc-text"> 当交互式证明遇上量子纠缠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#量子纠缠的力量"><span class="toc-text"> 量子纠缠的力量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reference"><span class="toc-text"> Reference</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>准备写一个系列, 介绍一下量子 PCP 猜想<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>以及今年被 Natarajan-Vidick 证明的 entangled game 版本<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>. 之所以我仍然称之为<strong>猜想</strong>, 是因为 Hamiltonian qPCP 仍然是<strong>公开问题</strong>, 并且 game qPCP 和 Hamiltonian qPCP 之间的联系仍然不完全清楚.</p>
<p>写这个系列的起因是准备这学期某门课的 presentation, 主要参考 Thomas Vidick 在今年 UCSD 的 Spring School on Quantum Computation 上的 Lecture Notes<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, Anand Natarajan 几天前<a href="https://simons.berkeley.edu/talks/anand-natarajan-06-15-18" target="_blank" rel="noopener">在 Simons Institute 的报告</a>, 以及相关的论文 (主要是<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>  和 <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup> 以及 <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>). 大致分为四篇:</p>
<ul>
<li>第一篇介绍交互式证明系统的一系列结果, 以及当我们把量子纠缠引入交互式证明系统会发生什么.</li>
<li>第二篇介绍 entangled game (以 CHSH game 和 Magic Square game 为例), 自检测 (self-testing), 以及它们和近似群表示 (即 Gowers-Hatami 定理<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>) 的联系.</li>
<li>第三篇介绍线性检测和指数规模的 PCP 定理的证明, 以及如何得到线性检测的量子对应.</li>
<li>第四篇介绍如何用前三篇的技术证明 (指数规模的) 交互式证明版本的量子 PCP 定理 (games qPCP), 以及如何使用纠错编码进一步设计效率更高 (多项式规模) 的极大纠缠态的自检测, 并简要介绍与 Hamiltonian qPCP 相关的内容与进展.</li>
</ul>
<p>为了笔者的方便起见, 假定读者们知道一点量子信息 (Dirac 记号 / CHSH game / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">B</mi><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{BQP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">B</span><span class="mord mathsf">Q</span><span class="mord mathsf">P</span></span></span></span></span>), 以及本科程度的计算复杂性理论 (知道 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 的两种等价定义, 能说清楚 Cook-Levin 定理的内容, 并且能大致理解证明).</p>
<p>本篇的主要内容如下:</p>
<ul>
<li>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 开始介绍交互式证明的一系列结果, 包括多轮交互式证明, 多个证明者的多伦交互式证明, 以及导出的一系列概率可检测证明 (PCP), 但是不会涉及任何密码学相关 (比如零知识证明) 的结果. 解释 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{PCP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">C</span><span class="mord mathsf">P</span></span></span></span></span> 定理中概率可检查证明 (或者说局部可检测证明) 的意义, 以及 PCP 定理的其他表述形式 (与不可近似性的联系.</li>
<li>定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 的量子对应 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span> 及其完全问题, 在此基础上介绍量子交互式证明系统相关的复杂性类的一系列定义 (一个证明者是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QIP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span> 和多个证明者是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>), 以及交互式证明版本的量子 PCP 猜想的定义. 然后介绍近年关于量子 PCP 猜想的几个弱化版本 (即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span> 的下界) 的结果, 并简要介绍与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span> 的可能上界有关的结果.</li>
</ul>
<p>下面开始正文.</p>
<h2 id="交互式证明-从-np-到-pcp-定理"><a class="markdownIt-Anchor" href="#交互式证明-从-np-到-pcp-定理"></a> 交互式证明: 从 NP 到 PCP 定理</h2>
<p>回顾一下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 的定义, 说的是如果一个问题在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 中, 那么对于这个问题的解, 存在一个确定性多项式时间算法验证它的正确性. 换一个角度看, 对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 中的问题, 这里有一个无所不能的证明者 (prover), 和一个计算能力受限 (确定性多项式时间) 的验证者 (verifier), 仅仅使用一次通信 (非交互式证明). 这里有几个地方可以放宽, 其一是我们可以允许验证者使用随机性, 其二是允许更多的通信次数(轮数).</p>
<p>因而, 把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 一般化意味着我们所讨论的证明系统从非交互式变成了交互式, 在我们的印象中满堂灌式教学效果往往不如师生大量交互的课堂 — 直觉上来说这样的交互会提高证明系统的计算能力, 但是能提高多少呢?</p>
<h3 id="形形色色的交互式证明系统"><a class="markdownIt-Anchor" href="#形形色色的交互式证明系统"></a> 形形色色的交互式证明系统</h3>
<p>考虑一个具有概率多项式时间的验证者, 允许多项式次轮通信 (一轮通信即验证者向证明者提问, 证明者给出答复), 这么这样的交互式证明对应的复杂性类是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{IP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup><sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>. 这里的&quot;概率多项式时间&quot;意味着, 如果证明是对的, 那么证明者以极高的概率 (比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">2/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord">2</span><span class="mord">/</span><span class="mord">3</span></span></span></span>) 接受, 称为完备性 (completeness); 否则, 证明者以极低的概率 (比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">1/3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span></span>) 接受, 称为可靠性 (soundness); 我们可以用诸如 Chernoff bound 之类的 concentration inequality 通过多次运行交互式证明使得接受 (或拒绝) 的概率任意接近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord">1</span></span></span></span> (或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord">0</span></span></span></span>).</p>
<p>于是使用代数化 (arithmetization) 和 sum-check protocol (即通过多轮交互迫使证明者不断说谎, 直到圆谎超出他的能力范围), 人们惊奇地发现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="sans-serif">P</mi><mrow><mi mathvariant="sans-serif">#</mi><mi mathvariant="sans-serif">P</mi></mrow></msup><mo>⊆</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{P}^{\mathsf{\#P}} \subseteq \mathsf{IP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8491079999999999em;"></span><span class="strut bottom" style="height:0.9850779999999999em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">P</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathsf mtight">#</span><span class="mord mathsf mtight">P</span></span></span></span></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span><sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>; 对这里的代数化技术稍加改进, 则可以进一步证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{IP}=\mathsf{PSPACE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span><sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup> – 这样的交互式证明的计算能力竟然和多项式空间一样!</p>
<p>那么如果我们有不止一个证明者呢? 可以证明多个证明者的情况和两个证明者等价<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>, 并且多轮交互和单次交互的计算能力等价, 于是这样的多证明者交互式证明系统对应的复杂性类是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{MIP}(f(n),c,s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 是交互者和证明者之间的通信代价 (即不能发送超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 的信息), <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">c</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> 分别是完备性 (completeness) 和可靠性 (soundness). 九十年代初的一系列结果证明了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">X</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>=</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NEXP} =\mathsf{PCP}(poly(n),poly(n))=\mathsf{MIP}(poly(n),1,1/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">E</span><span class="mord mathsf">X</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">C</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span><sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>], 也就是允许多项式规模通信多证明者交互式证明系统的计算能力和非确定性指数时间相同. 这里的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{PCP}(f(n),g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">C</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 是指在概率可检查证明中, 验证者向证明者提问的长度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f( n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 证明者给出的答案的长度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 比如说验证者问&quot;证明&quot;的 753-755 行是什么, 证明者给出&quot;证明&quot;中对应的部分. 这一系列结果使人们逐渐意识到, 交互式证明的力量比他们想象中要大得多, 关于交互式证明的系列奠基性工作荣获 1993 年的 Gödel Prize (理论计算机科学最高论文奖).</p>
<p>九十年代中期, 大家开始考虑如果限制这样的多证明者交互式证明系统的通信代价会发生什么, Arora 和 Safra 在 1992 年成功地<strong>把上述结果两边&quot;取了对数&quot;</strong><sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup> – 他们证明了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>ϵ</mi><mo>)</mo><mo>=</mo><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NP} = \mathsf{MIP}(\log n, 1, 1-\epsilon) = \mathsf{PCP}(\log n,\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">ϵ</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">C</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>. 几个月后, Arora-Lund-Motwani-Sudan-Szegedy 将这一结果进一步改进到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NP}=\mathsf{PCP}(\log n, 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">C</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>, 这一结果后来被称为 PCP 定理. 当然, 这一定理的历史地位, 很大程度上与后来建立的与不可近似性 (hardness of approximation) 的联系<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup>有关, PCP 定理的建立及其与不可近似性的联系分别荣获 2001 和 2011 年的 Gödel Prize.</p>
<h3 id="pcp-定理的等价描述"><a class="markdownIt-Anchor" href="#pcp-定理的等价描述"></a> PCP 定理的等价描述</h3>
<p>这里对 PCP 定理的名字稍微废话几句. PCP 定理说的是概率可检查证明 (probabilistic checkable proofs), 说的是所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 中的语言都有多项式规模的&quot;证明&quot;, 我们可以通过某个概率多项式时间算法, 只检查&quot;证明&quot;中的常数个位置来验证&quot;证明&quot;正确与否 — 这么说从字面上是对的, 不过并不符合史实<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>. 因为真实的原因是当年 Muli Safra 去 Berkeley 开会, 走错房间的缉毒警察来寻找毒品普斯普剂 (PCP), 其实更适合望文生义的名字是局部可检测证明 (locally testable proof).</p>
<p>另外, 这里对&quot;证明&quot;打引号的原因是, 每个证明者手上都有一份被<strong>处理</strong>过方便验证者提问的版本. 比如说对于可满足性问题 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">T</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{SAT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">A</span><span class="mord mathsf">T</span></span></span></span></span>) 某个实例的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 个变量的赋值 (即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 比特串), 为了通过检查常数个位置来判断&quot;证明&quot;的正确性, 我们必须对证明做一些处理 (比如使用某些性质良好的纠错编码) 使得它有某些良好性质 (比如是局部可检测的).</p>
<p>以上结果虽然强大, 但并不足以使得 PCP 定理在计算机复杂性理论中的地位几乎堪比 Cook-Levin 定理. 经典的 PCP 定理实际上有三种表述方式, 除了用局部可检测证明外, 也和一轮交互的多证明者的交互式证明系统等价, 等价性的证明使用交互式证明系统模拟概率可检查证明中的喻示 (oracle), 这一技术称为喻示化 (oracularization). 除此之外, PCP 定理也可以用不可近似性 (hardness of approximation)<sup class="footnote-ref"><a href="#fn15" id="fnref15:1">[15:1]</a></sup> 来刻画, 即一些 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mtext>-complete</mtext></mrow><annotation encoding="application/x-tex">\mathsf{NP}\text{-complete}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord text"><span class="mord">-complete</span></span></span></span></span> 问题的 gap 版本仍然是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mtext>-complete</mtext></mrow><annotation encoding="application/x-tex">\mathsf{NP}\text{-complete}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord text"><span class="mord">-complete</span></span></span></span></span> 的. 比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mtext>-</mtext><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">T</mi></mrow></mrow><annotation encoding="application/x-tex">3\text{-}\mathsf{SAT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord">3</span><span class="mord text"><span class="mord">-</span></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">A</span><span class="mord mathsf">T</span></span></span></span></span>, 即判断实例 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ϕ</span></span></span></span> (某类布尔表达式) 是否能被满足, 而对应的 gap 版本 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">G</mi><mi mathvariant="sans-serif">a</mi><mi mathvariant="sans-serif">p</mi></mrow><mtext>-</mtext><mn>3</mn><mtext>-</mtext><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">T</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{Gap}\text{-}3\text{-}\mathsf{SAT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathsf">G</span><span class="mord mathsf">a</span><span class="mord mathsf">p</span></span><span class="mord text"><span class="mord">-</span></span><span class="mord">3</span><span class="mord text"><span class="mord">-</span></span><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">A</span><span class="mord mathsf">T</span></span></span></span></span> 说的是判断实例 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">ϕ</span></span></span></span> 中所有子句被满足还是仅有少于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>7</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">7/8+\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord">7</span><span class="mord">/</span><span class="mord">8</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">ϵ</span></span></span></span> 的子句被满足. PCP 定理和不可近似性的联系, 使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi></mrow><mo>≠</mo><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{P}\neq \mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.716em;"></span><span class="strut bottom" style="height:0.9309999999999999em;vertical-align:-0.215em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≠</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 后来成为了近似算法中证明不可近似性的主要假设之一.</p>
<h2 id="当交互式证明遇上量子力学"><a class="markdownIt-Anchor" href="#当交互式证明遇上量子力学"></a> 当交互式证明遇上量子力学</h2>
<p>计算机科学家开始涉足量子计算始于上世纪九十年代初, 包括广为人知的 Shor 算法和刻画量子计算机多项式时间内求解的问题的复杂性类 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">B</mi><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{BQP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">B</span><span class="mord mathsf">Q</span><span class="mord mathsf">P</span></span></span></span></span>. 类似 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span>, Alexei Kitaev 在上世纪九十年代末定义了它的量子对应 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span><sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>], 即这里的验证者是一台量子计算机, 证明者和验证者之间的通信是量子态 (仅使用经典通信的复杂性类是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QCMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">C</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span><sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>], 但是我们并不知道它和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span> 是否等价). 这样的复杂性类的完全问题是局部哈密顿量问题 (local Hamiltonian problem), 几乎是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">X</mi><mtext mathvariant="sans-serif">-</mtext><mi mathvariant="sans-serif">k</mi><mtext mathvariant="sans-serif">-</mtext><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">T</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MAX\text{-}k\text{-}SAT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">A</span><span class="mord mathsf">X</span><span class="mord text"><span class="mord mathsf">-</span></span><span class="mord mathsf">k</span><span class="mord text"><span class="mord mathsf">-</span></span><span class="mord mathsf">S</span><span class="mord mathsf">A</span><span class="mord mathsf">T</span></span></span></span></span> 的直接对应:</p>
<blockquote>
<p><strong>局部哈密顿量问题 (local Hamiltonian problem)</strong></p>
<p>给定哈密顿量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>m</mi></mrow></mfrac><msub><mo>∑</mo><mi>i</mi></msub><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H = \frac{1}{m}\sum_i H_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.845108em;"></span><span class="strut bottom" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span></span></span></span><span style="top:-3.15em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy" style="height:0.2em;"><svg width="400em" height="0.2em" viewbox="0 0 400000 200" preserveaspectratio="xMinYMin slice"><path d="M0 80H400000 v40H0z M0 80H400000 v40H0z"/></svg></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16195399999999993em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> 作用在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 个量子比特上, 并且每个子项 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> 作用在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 个量子比特上, 此外 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∥</mi><msub><mi>H</mi><mi>i</mi></msub><mi mathvariant="normal">∥</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\|H_i\| \leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord">∥</span><span class="mord"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord">∥</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span> 至多有多项式个子项. 这一问题需要判断哈密顿量的基态能量 (最小特征值) 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>H</mi><mo>)</mo><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\lambda_{min}(H) \leq a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">a</span></span></span></span> 还是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo>(</mo><mi>H</mi><mo>)</mo><mo>≥</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\lambda_{min}(H) \geq b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathit">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">m</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">b</span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi><mo>≥</mo><mi mathvariant="normal">Ω</mi><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">a-b \geq \Omega(1/poly(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">a</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">b</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. 这里的基态是最小特征值对应的特征向量.</p>
</blockquote>
<p>不难看出上述问题和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">X</mi><mtext mathvariant="sans-serif">-</mtext><mi mathvariant="sans-serif">k</mi><mtext mathvariant="sans-serif">-</mtext><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">T</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MAX\text{-}k\text{-}SAT}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">A</span><span class="mord mathsf">X</span><span class="mord text"><span class="mord mathsf">-</span></span><span class="mord mathsf">k</span><span class="mord text"><span class="mord mathsf">-</span></span><span class="mord mathsf">S</span><span class="mord mathsf">A</span><span class="mord mathsf">T</span></span></span></span></span> 的对应关系: 布尔表达式中的子句 (约束, 可以表示成对角矩阵) 对应于哈密顿量的每个子项, 计算基态能量等价于计算被违反的约束个数. 上述 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span> 的定义给出了仅有一个证明者的量子非交互式证明系统.</p>
<p>在后文我们会提到, 在量子交互式证明 (即允许多轮交互) 中, 只有量子纠缠才会带来计算能力的惊人提升, 证明者和验证者之间使用量子态通信并没有任何优势! 值得一提的是, 我们并不知道在量子<strong>非交互式</strong>证明中, 使用量子态通信能否带来计算能力提升. 常见的量子非交互式证明关于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span> 的变种如下:</p>
<ul>
<li>如果仅有一个证明者, 如果他和验证者的通信使用经典信息的话, 那么这样的复杂性类是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QCMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">C</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span>;</li>
<li>如果有两个证明者 (多个的情况和两个等价), 但是他们之间并不允许共享纠缠态的话, 这样的复杂性类是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi><mo>(</mo><mn mathvariant="sans-serif">2</mn><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMA(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span><span class="mopen">(</span><span class="mord mathsf">2</span><span class="mclose">)</span></span></span></span></span>.</li>
</ul>
<p>至今我们仍然不知道上面两个复杂性类是否和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span> 相同, 尽管根据定义我们有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi><mo>(</mo><mn mathvariant="sans-serif">2</mn><mo>)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QCMA} \subseteq \mathsf{QMA} \subseteq \mathsf{QMA(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">C</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span><span class="mopen">(</span><span class="mord mathsf">2</span><span class="mclose">)</span></span></span></span></span>, 但是我们并不知道后者除了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">X</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NEXP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">E</span><span class="mord mathsf">X</span><span class="mord mathsf">P</span></span></span></span></span> 以外的非平凡上界.</p>
<p>下面我们继续讨论允许多轮交互的情形, 这就是量子交互式证明.</p>
<h3 id="量子交互式证明系统"><a class="markdownIt-Anchor" href="#量子交互式证明系统"></a> 量子交互式证明系统</h3>
<p>Kitaev-Watrous 在 2000 年对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span> 的定义一般化<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup>, 得到了量子交互式证明系统 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QIP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span>, 并证明了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi><mo>(</mo><mn mathvariant="sans-serif">3</mn><mo>)</mo><mo>=</mo><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QIP(3)=QIP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span><span class="mopen">(</span><span class="mord mathsf">3</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathsf">Q</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span> 即三轮交互的交互式证明系统的计算能力和多项式轮相同. 如果我们禁止这里的验证者使用量子计算, 那么就会得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{PSPACE}=\mathsf{IP}\subseteq \mathsf{QIP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span>. 不过出乎意料的是, Jain-Ji-Upadhyay-Watrous 在 2009 年证明了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QIP}\subseteq \mathsf{PSPACE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span><sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>, 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QIP}=\mathsf{IP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span> (STOC 2010 最佳论文奖), 即仅有一个证明者的情况下, 量子交互式证明系统没有任何优势!</p>
<p>那么, 如果我们有多个证明者呢? 对量子交互式证明的进一步泛化并不显然,  量子纠缠的存在使得我们有更多选择:</p>
<ul>
<li>证明者之间没有量子纠缠, 但是证明者和验证者的交互使用量子态, 验证者是量子的, 这样的复杂性类记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMIP}(poly(n),c,c-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>.</li>
<li>证明者之间具有量子纠缠, 但是证明者和验证者的交互使用量子态, 验证者是量子的, 这样的复杂性类记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMIP^*}(poly(n),c,c-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>.</li>
<li>证明者之间具有量子纠缠, 但是证明者和验证者的交互使用经典通信, 验证者是经典的, 这样的复杂性类记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}(poly(n),c,c-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>.</li>
</ul>
<p>需要说明的是, 在一些论文 (如 Rechardt-Unger-Vazirani <sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup> 中) 使用的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMIP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span> 即为这里的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>.  本文沿用 Thomas Vidick 在 UCSD Spring School 的 Lecture Notes<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup> 中使用的记号, “Q” 表示证明者和验证者之间的通信使用量子信息, “*” 则表示证明者们之间允许共享量子纠缠.</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QIP}=\mathsf{IP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span> 告诉我们使用量子态通信和使用量子计算验证并没有任何优势, 这样的结果同样适用于多证明者的量子交互式证明系统, 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMIP}=\mathsf{MIP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo><mo>=</mo><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}(poly(n),1,1/2)=\mathsf{QMIP^*}(poly(n),1,1/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>, 后者由  Rechardt-Unger-Vazirani 在 2013 年证明<sup class="footnote-ref"><a href="#fn21" id="fnref21:1">[21:1]</a></sup>. 因而对于量子交互式证明而言, 似乎它在计算上可能的优势来源就是量子纠缠, 但是量子纠缠究竟能在多大程度上提升交互式证明的能力呢?</p>
<p>回忆一下交互式证明系统版本的 PCP 定理, 它给出的对复杂性类 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span> 的刻画是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NP} \subseteq \mathsf{MIP}(\log n,1,1/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> – 即如果限制多证明者的交互式证明系统能使用的通信复杂度位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 的话, 那么它可以刻画 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mtext>-complete</mtext></mrow><annotation encoding="application/x-tex">\mathsf{NP}\text{-complete}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord text"><span class="mord">-complete</span></span></span></span></span> 问题. 既然我们想要它的&quot;量子化&quot;, 那就一方面允许非交互证明系统中的验证者使用量子计算, 另外一方面允许交互式证明系统的证明者们之间共享纠缠, 于是猜测的量子版本应该是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMA} \subseteq \mathsf{QMIP^*}(\log n,c,c-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>, 这就是 Fitzsimons-Vidick 在 2014 年末<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup>给出的 Games Quantum PCP Conjecture 的定义, 其中完备性和可靠性的间隙为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.03785em;">δ</span></span></span></span>.</p>
<p>也就是说, 交互式证明版本的量子 PCP 猜想 (games qPCP) 可以被表述如下:</p>
<blockquote>
<p>**量子 PCP 猜想的交互式证明版本 (games qPCP conjecture) **</p>
<p>给定共享纠缠态的多个证明者 (玩家) 的交互式证明系统 (entangled game), 以常数精度 (即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>−</mo><mi>s</mi><mo>=</mo><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">c-s=O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">s</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>) 估计验证者的最大接受概率 (或者 entangled game 中玩家的最大获胜概率) 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mtext>-hard</mtext></mrow><annotation encoding="application/x-tex">\mathsf{QMA}\text{-hard}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord text"><span class="mord">-hard</span></span></span></span></span> 的.</p>
</blockquote>
<p>需要说明的是, 我们上面的叙述中没有区分 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span> (即证明者和验证者的通信是否使用量子态), 这是因为 Reichardt-Unger-Vazirani <sup class="footnote-ref"><a href="#fn21" id="fnref21:2">[21:2]</a></sup> 和季铮锋 <sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup> 分别证明了在多项式或是对数规模的通信代价下均有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>=</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMIP^*}=\mathsf{MIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<h3 id="当交互式证明遇上量子纠缠"><a class="markdownIt-Anchor" href="#当交互式证明遇上量子纠缠"></a> 当交互式证明遇上量子纠缠</h3>
<p>上面的 Games qPCP 看起来很强, 直接证明这一论断似乎并不容易. 我们可以考虑把它从证明长度, 近似的精确程度和通信代价三个方面进行弱化:</p>
<ul>
<li>既然是 PCP 定理的量子版本, 那么我们大可只&quot;量子化&quot;右边, 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NP} \subseteq \mathsf{MIP^*}(\log n,c,c-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>. 要么再不妨两边取个指数, 得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">X</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NEXP}\subseteq \mathsf{MIP^*}(poly(n),c,c-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">E</span><span class="mord mathsf">X</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>. 这个版本说的是多证明者量子交互式证明系统的计算能力并不弱于经典交互式证明系统.</li>
<li>观察一下上面的局部哈密顿量问题, 它的基态能量的精度是逆多项式的, 那么我们自然也可以放宽 entangled game 中对获胜概率的精度要求, 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMA} \subseteq \mathsf{MIP^*}(\log n,c,c-1/poly(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. 这个版本说的是多证明者量子交互式证明系统 (对数规模通信代价) 的计算能力不弱于量子非交互式证明 (多项式规模通信代价).</li>
<li>注意到右边允许的通信代价是对数规模的, 我们也可以只把右边&quot;取个指数&quot;, 得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMA} \subseteq \mathsf{MIP^*}(poly(n),c,c-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>. 在经典 PCP 定理的系列结果中, 这里对应的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NP}\subseteq\mathsf{MIP}(poly(n),c,c-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>. 这个版本给出了指数规模 PCP 定理的量子版本, 经典情形下这一定理的证明由线性检测 (linearity testing) 和二次方程可解性 (quadratic solvability) 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mtext>-complete</mtext></mrow><annotation encoding="application/x-tex">\mathsf{NP}\text{-complete}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord text"><span class="mord">-complete</span></span></span></span></span> 给出.</li>
</ul>
<p>事实上, 第三种弱化版本并不平凡, 尽管证明者给出的&quot;证明&quot; 的长度是指数的, 但是验证者只需要随机验证常数行就可以以极高的概率判断其正确性. 上面三个弱化情形几乎被完全解决:</p>
<ul>
<li>Ito-Vidick 在 2012 年证明<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup>了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">X</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NEXP} \subseteq \mathsf{MIP^*}(poly(n),1,1-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">E</span><span class="mord mathsf">X</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NP}\subseteq\mathsf{MIP^*}(\log n,1,1-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>, 不过需要五个证明者 (FOCS 2012 最佳论文奖). 这一工作意味着多证明者的量子交互式证明并不弱于经典情形. Vidick (2013)<sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup> 和 Natarajan-Vidick (2017)<sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup> 分别把证明者个数减少到三个和两个.</li>
<li>季铮锋在 2015 年证明<sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup>了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi>c</mi><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMA} \subseteq \mathsf{MIP^*}(\log n,c,c-1/poly(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 这一工作意味着多证明者量子交互式证明并不如弱于量子非交互式证明. 如果考虑指数小的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>−</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">c-s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">c</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">s</span></span></span></span> 间隙的话, 上述下界可以被加强<sup class="footnote-ref"><a href="#fn23" id="fnref23:1">[23:1]</a></sup>到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">X</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NEEXP} \subseteq \mathsf{MIP^*}(poly(n),1,1-2^{-n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.771331em;"></span><span class="strut bottom" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">E</span><span class="mord mathsf">E</span><span class="mord mathsf">X</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. 几周前, Fitzsimons-Ji-Vidick-Yuen 将这一结果进一步加强<sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup>到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><msup><mi mathvariant="sans-serif">E</mi><mrow><mi mathvariant="sans-serif">R</mi><mo>(</mo><mi mathvariant="sans-serif">n</mi><mo>)</mo></mrow></msup><mi mathvariant="sans-serif">X</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>exp</mi><mo>⁡</mo><mo>(</mo><mi>C</mi><mi>exp</mi><mo>⁡</mo><mo>(</mo><mo>⋯</mo><mspace width="0.16667em"></mspace><mo separator="true">,</mo><mi>exp</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{NE^{R(n)}XP} \subseteq \mathsf{MIP^*}(poly(n),1,1-\exp(C \exp(\cdots,\exp(n))))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8879999999999999em;"></span><span class="strut bottom" style="height:1.138em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord"><span class="mord mathsf">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathsf mtight">R</span><span class="mopen mtight">(</span><span class="mord mathsf mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord mathsf">X</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="minner">⋯</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mspace thinspace"></span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>, 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><msup><mi mathvariant="sans-serif">E</mi><mrow><mi mathvariant="sans-serif">R</mi><mo>(</mo><mi mathvariant="sans-serif">n</mi><mo>)</mo></mrow></msup><mi mathvariant="sans-serif">X</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NE^{R(n)}XP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8879999999999999em;"></span><span class="strut bottom" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord"><span class="mord mathsf">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathsf mtight">R</span><span class="mopen mtight">(</span><span class="mord mathsf mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord mathsf">X</span><span class="mord mathsf">P</span></span></span></span></span> 表示非确定性 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">R(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 重指数时间内可判定的语言.</li>
<li>Natarajan-Vidick 在 2016 年借助群表示论中的 Gowers-Hatami 定理<sup class="footnote-ref"><a href="#fn6" id="fnref6:1">[6:1]</a></sup> <strong>直接</strong>证明了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMA} \subseteq \mathsf{MIP^*}(poly(n),1,1-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>, 这一结果给出指数规模 PCP 定理的量子版本<sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup>. 本系列文章介绍的大部分技术均来自这篇论文. 不过如何把证明者个数从五个减少到两个仍然是公开问题, 另外需要说明的是, 这一结果可以由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">X</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMA} \subseteq \mathsf{PP} \subseteq \mathsf{PSPACE} \subseteq \mathsf{NEXP} \subseteq \mathsf{MIP^*}(poly(n),1,1-\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">E</span><span class="mord mathsf">X</span><span class="mord mathsf">P</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span> 导出.</li>
</ul>
<p>其后 Natarajan-Vidick 通过一系列改进, 在 2017 年末证明了在随机规约下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>p</mi><mi>o</mi><mi>l</mi><mi>y</mi><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>ϵ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMA}\subseteq \mathsf{MIP^*}(poly\log(n),1,1-\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">ϵ</span><span class="mclose">)</span></span></span></span>, 并在 2018 年四月份进一步证明<sup class="footnote-ref"><a href="#fn2" id="fnref2:2">[2:2]</a></sup>了在随机规约下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>ϵ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathsf{QMA} \subseteq \mathsf{MIP^*}(\log n,1,1-\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">n</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">ϵ</span><span class="mclose">)</span></span></span></span> , 这一结果被称 Games Quantum PCP Theorem. 至此, 多证明者交互式证明系统 (通讯代价限制在对数, 以常数精度近似获胜概率) 的下界已经有了多种不同的刻画方式, 并且在某些参数限制下几乎被完全解决.</p>
<h3 id="量子纠缠的力量"><a class="markdownIt-Anchor" href="#量子纠缠的力量"></a> 量子纠缠的力量</h3>
<p>自然, 另外一个问题则是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\mathsf{MIP}^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.773036em;"></span><span class="strut bottom" style="height:0.773036em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.773036em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> 的上界, 也就是说量子纠缠的力量到底有多大? 然而我们对此一无所知.</p>
<p>直觉上来说我们并不知道这样的上界是什么样的, 因为我们根本不知道<strong>证明者们到底能用多少纠缠</strong>. 可能的猜测之一<sup class="footnote-ref"><a href="#fn28" id="fnref28:1">[28:1]</a></sup>是它包括了所有可判定语言以及某些不可判定 (undeciable) 语言. 而可能的途径则是刻画可能的<strong>量子关联的可能集合</strong>, 即对于量子交互式证明系统, 给定问题,并选择合适的量子策略 (可观测量, 有可能是无穷维的) 再给出某些答案的分布的可能集合 — 这样的集合是凸的 (convex), 但是我们并不知道它们是否封闭 (closed):</p>
<ul>
<li>William Slofstra 在 2017 年证明<sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup>了其中一类重要的量子关联的可能集合不是 closed, 这意味着判断一个 entangled game 获胜概率是否严格为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base"><span class="mord">1</span></span></span></span> 是<strong>不可判定的</strong>!</li>
<li>如果能够证明算子代数中的 Connes Embedded Conjecture, 那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span> 将包含所有可判定语言.</li>
</ul>
<p>说到这里, 看起来量子纠缠的力量非常惊人: 通过把多证明者量子交互式证明系统的完备性和可靠性的间隙从常数逐渐缩小到逆多重指数, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>能够验证的语言从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">A</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{QMA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord mathsf">A</span></span></span></span></span> 逐渐扩大到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><msup><mi mathvariant="sans-serif">E</mi><mrow><mi mathvariant="sans-serif">R</mi><mo>(</mo><mi mathvariant="sans-serif">n</mi><mo>)</mo></mrow></msup><mi mathvariant="sans-serif">X</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NE^{R(n)}XP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8879999999999999em;"></span><span class="strut bottom" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord"><span class="mord mathsf">E</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathsf mtight">R</span><span class="mopen mtight">(</span><span class="mord mathsf mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord mathsf">X</span><span class="mord mathsf">P</span></span></span></span></span>; 甚至当我们把它们的间隙变得几乎无穷小的时候, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span> 包含了不可判定的语言!</p>
<p>目前为止, 我们仍然没有给出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><msup><mi mathvariant="sans-serif">P</mi><mo>∗</mo></msup></mrow></mrow><annotation encoding="application/x-tex">\mathsf{MIP^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord"><span class="mord mathsf">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span> 的确切定义, 看起来证明者们之间共享的量子纠缠是它的计算能力的主要来源, 熟悉 Bell 不等式的读者也许会觉得这一现象很像是量子力学中的非局域性 (non-locality). 事实上由 Bell 不等式导出的 CHSH game 就是 entangled game (quantum game) 的典型例子. 而复杂性类 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\mathsf{MIP}^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.773036em;"></span><span class="strut bottom" style="height:0.773036em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.773036em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> 就是由 entangled game 所定义的<sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>, 即所有的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mi mathvariant="sans-serif">M</mi><mi mathvariant="sans-serif">I</mi><mi mathvariant="sans-serif">P</mi></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\mathsf{MIP}^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.773036em;"></span><span class="strut bottom" style="height:0.773036em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">M</span><span class="mord mathsf">I</span><span class="mord mathsf">P</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.773036em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> protocol 其实都是一个 entangled game, 在下一篇中我们将介绍它的严格定义及常见例子 CHSH game 和 Magic Square game.</p>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Aharonov, Dorit, Itai Arad, and Thomas Vidick. “Guest column: the quantum PCP conjecture.” <em>Acm sigact news</em> 44.2 (2013): 47-79. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://arxiv.org/abs/1801.03821" target="_blank" rel="noopener">[1801.03821] Low-degree testing for quantum states, and a quantum entangled games PCP for QMA</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a> <a href="#fnref2:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://cseweb.ucsd.edu/~slovett/workshops/quantum-computation-2018/material.html" target="_blank" rel="noopener">https://cseweb.ucsd.edu/~slovett/workshops/quantum-computation-2018/material.html</a> <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Natarajan, Anand, and Thomas Vidick. “A quantum linearity test for robustly verifying entanglement.” In <em>Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing</em>, pp. 1003-1015. ACM, 2017. <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Coladangelo, Andrea, and Jalex Stark. “Robust self-testing for linear constraint system games.” <em>arXiv preprint arXiv:1709.09267</em> (2017). <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Gowers, William Timothy, and Omid Hatami. “Inverse and stability theorems for approximate representations of finite groups.” <em>Sbornik: Mathematics</em> 208, no. 12 (2017): 1784. <a href="#fnref6" class="footnote-backref">↩︎</a> <a href="#fnref6:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Goldwasser, Shafi, Silvio Micali, and Charles Rackoff. “The knowledge complexity of interactive proof systems.” <em>SIAM Journal on computing</em> 18.1 (1989): 186-208. <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>Babai, László, and Shlomo Moran. “Arthur-Merlin games: a randomized proof system, and a hierarchy of complexity classes.” <em>Journal of Computer and System Sciences</em> 36.2 (1988): 254-276. <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>Lund, C., L. Fortnow, H. Karloff, and N. Nisan. “Algebraic methods for interactive proof systems.” In <em>Proceedings (1990) 31st Annual Symposium on Foundations of Computer Science</em>, pp. 2-10. IEEE, 1990. <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>Shamir, Adi. “IP=PSPACE.” <em>Journal of the ACM (JACM)</em> 39.4 (1992): 869-877. <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>Ben-Or, Michael, et al. “Multi-prover interactive proofs: How to remove intractability assumptions.” <em>Proceedings of the twentieth annual ACM symposium on Theory of computing</em>. ACM, 1988. <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>Babai, László, Lance Fortnow, and Carsten Lund. “Non-deterministic exponential time has two-prover interactive protocols.” <em>Computational complexity</em> 1.1 (1991): 3-40. <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>Arora, Sanjeev, and Shmuel Safra. “Probabilistic checking of proofs: A new characterization of NP.” <em>Journal of the ACM (JACM)</em> 45.1 (1998): 70-122. <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>Arora, Sanjeev, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy. “Proof verification and the hardness of approximation problems.” <em>Journal of the ACM (JACM)</em> 45, no. 3 (1998): 501-555. <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>Håstad, Johan. “Some optimal inapproximability results.” <em>Journal of the ACM (JACM)</em> 48.4 (2001): 798-859. <a href="#fnref15" class="footnote-backref">↩︎</a> <a href="#fnref15:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p><a href="https://courses.cs.washington.edu/courses/cse533/05au/pcp-history.pdf" target="_blank" rel="noopener">A history of the PCP Theorem - University of Washington</a> <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>Kitaev, Alexei. “Quantum NP.” <em>Talk at AQIP</em> 99 (1999). <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>Aharonov, Dorit, and Tomer Naveh. “Quantum NP-a survey.” <em>arXiv preprint quant-ph/0210077</em> (2002). <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>Kitaev, Alexei, and John Watrous. “Parallelization, amplification, and exponential time simulation of quantum interactive proof systems.” <em>Proceedings of the thirty-second annual ACM symposium on Theory of computing</em>. ACM, 2000. <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>Jain, Rahul, Zhengfeng Ji, Sarvagya Upadhyay, and John Watrous. “QIP=PSPACE.” <em>Communications of the ACM</em> 53, no. 12 (2010): 102-109. <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>Reichardt, Ben W., Falk Unger, and Umesh Vazirani. “Classical command of quantum systems.” <em>Nature</em> 496.7446 (2013): 456. <a href="#fnref21" class="footnote-backref">↩︎</a> <a href="#fnref21:1" class="footnote-backref">↩︎</a> <a href="#fnref21:2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>Fitzsimons, Joseph, and Thomas Vidick. “A multiprover interactive proof system for the local Hamiltonian problem.” Proceedings of the 2015 Conference on Innovations in Theoretical Computer Science. ACM, 2015. <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>Ji, Zhengfeng. “Compression of quantum multi-prover interactive proofs.” <em>Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing</em>. ACM, 2017. <a href="#fnref23" class="footnote-backref">↩︎</a> <a href="#fnref23:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Ito, Tsuyoshi, and Thomas Vidick. “A multi-prover interactive proof for NEXP sound against entangled provers.” In <em>Foundations of Computer Science (FOCS), 2012 IEEE 53rd Annual Symposium on</em>, pp. 243-252. IEEE, 2012. <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>Vidick, Thomas. “Three-player entangled XOR games are NP-hard to approximate.” <em>SIAM Journal on Computing</em> 45.3 (2016): 1007-1063. <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>Natarajan, Anand, and Thomas Vidick. “Two-player entangled games are NP-hard.” <em>arXiv preprint arXiv:1710.03062</em> (2017). <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>Ji, Zhengfeng. “Classical verification of quantum proofs.” <em>Proceedings of the forty-eighth annual ACM symposium on Theory of Computing</em>. ACM, 2016. <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>Fitzsimons, Joseph, Zhengfeng Ji, Thomas Vidick, and Henry Yuen. “Quantum proof systems for iterated exponential time, and beyond.” <em>arXiv preprint arXiv:1805.12166</em> (2018). <a href="#fnref28" class="footnote-backref">↩︎</a> <a href="#fnref28:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>Slofstra, William. “The set of quantum correlations is not closed.” <em>arXiv preprint arXiv:1703.08618</em> (2017). <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>Cleve, Richard, Peter Hoyer, Benjamin Toner, and John Watrous. “Consequences and limits of nonlocal strategies.” In <em>Computational Complexity, 2004. Proceedings. 19th IEEE Annual Conference on</em>, pp. 236-249. IEEE, 2004. <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://climberpi.github.io">Climber.pI</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://climberpi.github.io/2018/06/22/games-qpcp-interactive-proofs/">http://climberpi.github.io/2018/06/22/games-qpcp-interactive-proofs/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/理论计算机科学/">理论计算机科学</a>
            
              <a href="/tags/量子计算理论/">量子计算理论</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/06/27/games-qpcp-self-testing/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">量子 PCP 猜想浅说 (二): 量子纠缠的交互式证明验证</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2018/04/19/ugc/">
        <span class="next-text nav-default">说点 Unique Games Conjecture</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNTE4NS8xMTcyMA">
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>  
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:yupan.liu@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/climberpi" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2018 - 
    
    2023

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Climber.pI</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  
   <script type="text/javascript">
	(function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
  </script>




    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>
<link rel="stylesheet" href="/js/src/katex.min.css" integrity="sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei" crossorigin="anonymous"><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  </body>
</html>
