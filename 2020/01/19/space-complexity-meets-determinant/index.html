<!DOCTYPE html>
<html lang="en">
  <head>
    
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="本文介绍了对数空间复杂性的一系列基本结果  (Immerman-Szelepcsényi 定理),以及一些对数空间完全问题, 如图论中常见的连通性判断和寻找强连通分量, 还有 2-SAT. 此外, 空间复杂性也和条件数良好的整数矩阵的行列式计算有关. 尽管对于经典多数空间复杂性, 我们只有对数平方空间的算法, 但是这一问题却有量子对数空间算法. 我们有可能证明 NL=L 吗?"/>




  <meta name="keywords" content="理论计算机科学, 量子计算理论, Complexity Meets Quantum" />










  <link rel="alternate" href="/atom.xml" title="Complexity Meets Quantum">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=2.6.0" />



<link rel="canonical" href="http://climberpi.github.io/2020/01/19/space-complexity-meets-determinant/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  


  <script id="google_analytics">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-116370825-1', 'auto');
        ga('send', 'pageview');
  </script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "nI9TEHVDOnoMEywQ0nzNyJOI-gzGzoHsz",
      appKey: "rvxJbiglsBWMoxSQsvwmwX7d"
    });
  </script>





    <title> 当对数空间复杂性遇上强联通图和行列式 - Complexity Meets Quantum </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Complexity Meets Quantum</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="/search">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Complexity Meets Quantum</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/search">
            
            
              Search
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          当对数空间复杂性遇上强联通图和行列式
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-01-19
        </span>
        
          <div class="post-category">
            
              <a href="/categories/理论计算机科学/">理论计算机科学</a>
            
              <a href="/categories/理论计算机科学/量子计算理论/">量子计算理论</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2020/01/19/space-complexity-meets-determinant/"
             data-title="当对数空间复杂性遇上强联通图和行列式">
            Views
          </div>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#从图的强联通性说起"><span class="toc-text"> 从图的强联通性说起</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何在多项式空间中判断图的强连通性"><span class="toc-text"> 如何在多项式空间中判断图的强连通性?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哈密顿量基态的连通性"><span class="toc-text"> 哈密顿量基态的&quot;连通性&quot;</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对数空间复杂性浅说"><span class="toc-text"> 对数空间复杂性浅说</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#path-is-nl-complete"><span class="toc-text"> PATH is NL-complete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sat-is-nl-complete"><span class="toc-text"> 2-SAT is NL​-complete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#immermanszelepcsényi-定理"><span class="toc-text"> Immerman–Szelepcsényi 定理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#当空间复杂性遇上线性方程组"><span class="toc-text"> 当空间复杂性遇上线性方程组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hhl-算法在量子空间复杂性中的应用"><span class="toc-text"> HHL 算法在量子空间复杂性中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#我们能证明-lnl-吗"><span class="toc-text"> 我们能证明 L=NL 吗?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-text"> 参考文献</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>本文介绍了对数空间复杂性, 譬如如何刻画空间复杂性 (Immerman-Szelepcsényi 定理), 以及一些常见图论问题 (如判断图的连通性, 或者找图的强联通分量) 的对数多项式空间算法. 诸如此类的图论问题有广为人知的多项式时间算法, 因而也在各类算法竞赛中屡见不鲜, 对数空间复杂性的一系列结果也许是引入计算复杂性理论的很好的切入点. 有趣的是, 类似图的连通性这样的问题<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>, 也可以在量子计算 (具体来说是哈密顿量) 的上下文中定义类似的问题<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>, 并证明空间复杂性有关的结果.</p>
<p>除此之外, 空间复杂性也和条件数良好的整数矩阵的行列式计算有关. 尽管对于经典对数空间复杂性, 我们只有非确定性时间的对数空间算法 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span>), 但是这一问题却有量子对数空间算法<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> (启发自求解线性系统的著名的 HHL 算法). 最近的一些尝试<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>得到了一些中间结果, 我们能证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">L</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf NL}={\sf L}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">L</span></span></span></span></span></span> 吗?</p>
<p>下面开始正文.</p>
<h2 id="从图的强联通性说起"><a class="markdownIt-Anchor" href="#从图的强联通性说起"></a> 从图的强联通性说起</h2>
<p>给定顶点标号为长度-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span>比特串的有向图 (即至多有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个顶点), 判断这个有向图是否是强连通 (strongly connectivity) 的不但有多项式空间 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><annotation encoding="application/x-tex">\sf PSPACE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span>) 算法, 而且这个问题实际上还是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><annotation encoding="application/x-tex">\sf PSPACE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span>-complete 的. 这个问题和空间复杂性理论有很深的联系, 事实上我们还可以证明更强的结果:</p>
<blockquote>
<p><strong>定理 1.</strong> 对于所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>≤</mo><mi>s</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≤</mo><mrow><mrow><mi mathvariant="normal">p</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">y</mi></mrow></mrow><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(\log(n)) \leq s(n) \leq {\rm poly}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord">Ω</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">p</span><span class="mord mathrm">o</span><span class="mord mathrm">l</span><span class="mord mathrm" style="margin-right:0.01389em;">y</span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 给定顶点能被长度-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 高效编码的有向图, 即顶点标号的长度不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">s(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 判断这个有向图是否强连通有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><mo>[</mo><mi>O</mi><mo>(</mo><mi>s</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">{\sf NSPACE}[O(s(n))]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span> 的算法, 并且这一问题在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><mo>[</mo><mi>s</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">{\sf SPACE}[s(n)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span><span class="mopen">[</span><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span> 的规约下是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><mo>[</mo><mi>O</mi><mo>(</mo><mi>s</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">{\sf NSPACE}[O(s(n))]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>-complete 的.</p>
</blockquote>
<p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">s(n)=\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 的时候, 这一问题是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span>-complete 的. 这一结果的证明并不平凡, 尽管可以在本科层次的计算理论教材上找到 (比如 Sipser). 注意到一个有向图是强联通的, 当且仅当图上的任意两个顶点之间都存在一条连通路径. 那么我们可以设计一个 coNL 算法, 非确定性的选择一对顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span></span></span></span> , 然后看看他们之间是否存在连通路径 (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span></span></span></span>-connectivity).</p>
<p>Immerman 和 Szelepcsényi 在上世纪八十年代末, 分别<strong>独立</strong>证明了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">o</mi><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf NL}={\sf coNL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">c</span><span class="mord mathsf">o</span><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span></span>, 这一结果荣膺 1995 年的 Godel Prize – 可以说跟 Cook-Levin 定理, 还有求解线性规划的内点法 (interior-point method) 一样是冷战遗产了, 希望接下来的一二十年不会有更多的新冷战遗产.</p>
<p>另外, 注意到多项式的多项式仍然是多项式, 那么Savitch 定理 (1970) 可以导出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf NPSPACE}={\sf PSPACE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span></span>. 即考虑 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 是多项式的情况, 带入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≥</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>⊆</mo><mrow><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><mo>(</mo><msup><mi>f</mi><mn>2</mn></msup><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\forall f(n)\geq \log(n), {\sf NSPACE}(f(n)) \subseteq {\sf SPACE}(f^2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base"><span class="mord">∀</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>. 那么定理 1 证明了, 给定指数多个顶点的有向图, 判定它是否是强联通的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><annotation encoding="application/x-tex">\sf PSPACE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span>-complete 的.</p>
<p>我会在下一节证明定理 1, 并在之后简单介绍与之相关的 open problem 和新结果.</p>
<h4 id="如何在多项式空间中判断图的强连通性"><a class="markdownIt-Anchor" href="#如何在多项式空间中判断图的强连通性"></a> 如何在多项式空间中判断图的强连通性?</h4>
<p>到现在为止, 如果我们把这一节中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 个顶点的有向图换成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.664392em;"></span><span class="strut bottom" style="height:0.664392em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个顶点的有向图, 那么我们就得到了一个 NPSPACE 算法: 非确定性地枚举有向图中的顶点对, 验证他们直接是否不存在连通路径.</p>
<p>Savitch 定理告诉我们, 这样的算法可以用 PSPACE 算法来模拟. 做法就是考虑 NPSPACE 计算中的两个 configuration <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">b</span></span></span></span> 和这样的计算的步数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span></span></span></span>, 考虑这两个 configuration <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">b</span></span></span></span> 的计算中间的 configuration <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">m</span></span></span></span> , 分别验证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">a</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>m</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(m,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit">m</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span> 能不能用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">t/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">t</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 步的非确定性多项式空间算法完成, 然后继续递归 . 由于每一步验证都需要多项式空间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> , 而可能的计算路径的深度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≤</mo><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">d(n) \leq O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 我们可以用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mi>log</mi><mo>⁡</mo><mi>d</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n) \log d(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">d</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 的空间, 即多项式空间模拟. 综合以上步骤, 即判断图强联通性的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">o</mi><mtext mathvariant="sans-serif">-</mtext><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><annotation encoding="application/x-tex">\sf co\text{-}NPSPACE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">c</span><span class="mord mathsf">o</span><span class="mord text"><span class="mord mathsf">-</span></span><span class="mord mathsf">N</span><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span> 算法 - 对应的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NPSPACE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span> 算法 - 用以模拟的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><annotation encoding="application/x-tex">\sf PSPACE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span> 算法, 我们得到了判断指数规模的有向图是否强联通的多项式空间算法.</p>
<h4 id="哈密顿量基态的连通性"><a class="markdownIt-Anchor" href="#哈密顿量基态的连通性"></a> 哈密顿量基态的&quot;连通性&quot;</h4>
<p>首先多写两个有趣但不是那么重要的结果. 也即 PSPACE-complete 版本的 s,t-connectivity, 我们还可以证明它的一些有趣的变种, 比如说布尔表达式的满足赋值的&quot;连通性&quot;, 或者哈密顿量的基态的&quot;连通性&quot;, 也是 PSPACE-complete 的.</p>
<p>我们知道带量词 (quantifier) 的布尔函数的可满足性是 PSPACE-complete 的, 那么如果给定两个满足的赋值 (assignment), 我们可以判断是否存在一条这两个赋值之间的连通路径吗? 即每次只更改一个变量的值, 但是新的赋值仍然满足这个布尔表达式. 这一问题除了很简单的情形有多项式时间算法, 其他时候都是 PSPACE-complete 的 <sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>.</p>
<p>有趣的是, 这一问题的量子版本也是对的. 我们可以定义一个 local Hamiltonian, 并询问它的指数精度的基态能量, 这一问题是 PSPACE-complete 的 <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>. 那么如果给定这个 local Hamiltonian 的两个基态, 我们能不能判断这两个基态是不是&quot;连通&quot;的呢? 如果我们只允许作用单比特量子门, 那么判断这样的指数长的&quot;连通&quot;两个基态的量子门序列是否存在也是 PSPACE-complete 的 <sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>.</p>
<h2 id="对数空间复杂性浅说"><a class="markdownIt-Anchor" href="#对数空间复杂性浅说"></a> 对数空间复杂性浅说</h2>
<h4 id="path-is-nl-complete"><a class="markdownIt-Anchor" href="#path-is-nl-complete"></a> PATH is NL-complete</h4>
<p>首先考虑一个类似的问题: 给定一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 个顶点的有向图 (即顶点的二进制编号长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Theta(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord">Θ</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>), 和图上两个顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span></span></span></span>, 那么这两个顶点之间是否存在连通路径呢? 这个问题通常被称作 st-connectivity (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">O</mi><mi mathvariant="sans-serif">N</mi></mrow></mrow><annotation encoding="application/x-tex">\sf STCON</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">S</span><span class="mord mathsf">T</span><span class="mord mathsf">C</span><span class="mord mathsf">O</span><span class="mord mathsf">N</span></span></span></span></span>) 或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">H</mi></mrow></mrow><annotation encoding="application/x-tex">\sf PATH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">T</span><span class="mord mathsf">H</span></span></span></span></span>, 可以证明它是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span>-complete 的, 证明包括两个部分:</p>
<p>(1) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">H</mi></mrow></mrow><annotation encoding="application/x-tex">\sf PATH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">T</span><span class="mord mathsf">H</span></span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span> 算法</p>
<p>由于只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 个顶点, 不妨给每个顶点一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 长度的二进制编号, 那么我们可以在对数空间里盯着一个顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span>, 然后看看它的邻居是谁. 由于这里还能用非确定性, 所以我们可以同时看着它的所有邻居, 并且不断重复这个过程, 直到我们看到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span></span></span></span>. 由于只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 个顶点, 所以在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 步之后还不能同时看到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span></span></span></span> 的话, 那么他们肯定是不连通的.</p>
<p>(2) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">T</mi><mi mathvariant="sans-serif">H</mi></mrow></mrow><annotation encoding="application/x-tex">\sf PATH</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">T</span><span class="mord mathsf">H</span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span>-hard 的</p>
<p>考虑一个对数空间的非确定性图灵机, 我们把纸带上写的东西记作 configuration. 于是我们可以根据这个图灵机的转移情况构造一个图, 每个 configuration 是图上的一个顶点; 而两个顶点之间有边, 仅当我们可以用非确定性对数空间的一步计算从一个 configuration 跳到另一个 configuration. 那么任何的非确定性对数空间的计算, 都可以写成一个这样的有向图. 由于图的顶点 (configuration) 的二进制编号长度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>, 不难验证这里的规约只用了对数空间.</p>
<p>所以给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 个顶点的有向图和两个顶点, 判断顶点之间是否有连通路径是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span>-complete 的.</p>
<h4 id="2-sat-is-nl-complete"><a class="markdownIt-Anchor" href="#2-sat-is-nl-complete"></a> 2-SAT is NL​-complete</h4>
<p>我们在上一节简单提及了判断有向图是否强联通的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">o</mi><mtext mathvariant="sans-serif">-</mtext><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf co\text{-}NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">c</span><span class="mord mathsf">o</span><span class="mord text"><span class="mord mathsf">-</span></span><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span> 算法, 非确定地选取一对顶点, 然后看看是不是连通路径不存在. 类似地, 我们还可以证明:</p>
<blockquote>
<p><strong>定理 2.</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mn mathvariant="sans-serif">2</mn><mtext mathvariant="sans-serif">-</mtext><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">T</mi></mrow></mrow><annotation encoding="application/x-tex">\sf 2\text{-}SAT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">2</span><span class="mord text"><span class="mord mathsf">-</span></span><span class="mord mathsf">S</span><span class="mord mathsf">A</span><span class="mord mathsf">T</span></span></span></span></span> 也是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span>-complete 的.</p>
</blockquote>
<p>做法并不复杂, 把 2-SAT 和子句 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mi>j</mi></msub><mo>=</mo><mo>(</mo><msub><mi>x</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo>∨</mo><mi mathvariant="normal">¬</mi><msub><mi>x</mi><msub><mi>i</mi><mn>2</mn></msub></msub><mo>∨</mo><msub><mi>x</mi><msub><mi>i</mi><mn>5</mn></msub></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">c_j = (x_{i_1} \vee \neg x_{i_2} \vee x_{i_5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"></span></span></span></span></span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"></span></span></span></span></span><span class="mclose">)</span></span></span></span> 当成二分图的一边, 然后把变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> 和它的 negation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\neg x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord">¬</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> 当成二分图的另一边; 然后用 PATH 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">o</mi><mtext mathvariant="sans-serif">-</mtext><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf co\text{-}NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">c</span><span class="mord mathsf">o</span><span class="mord text"><span class="mord mathsf">-</span></span><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span> 算法, 分别判断:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\neg x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord">¬</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> 的路径是否存在, 不存在的话直接拒绝, 因为找不到满足布尔表达式的 assignment;</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\neg x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord">¬</span><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> 的路径是否存在, 存在的话直接拒绝, 因为前面找到的 assignment 是自相矛盾的.</li>
</ul>
<p>由于判定有向图是否强联通是有多项式时间算法的, 不难得出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow><mo>⊆</mo><mrow><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NL}\subseteq\mathsf{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathsf">P</span></span></span></span></span>. 但是众所周知 3-SAT 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span></span></span>-complete 的 (Cook-Levin 定理, 1971), 并且另一方面, 用空间谱系定理 (space hierarchy theorem) 可以导出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow><mo>⊊</mo><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">\mathsf{NL} \subsetneq{\sf PSPACE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊊</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span></span>. 于是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>⊆</mo><mrow><mrow><mi mathvariant="sans-serif">P</mi></mrow></mrow><mo>⊆</mo><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi></mrow></mrow><mo>⊆</mo><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf NL} \subseteq {\sf P} \subseteq {\sf NP} \subseteq {\sf PSPACE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">P</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span></span> 之中, 必然有一环是真包含.</p>
<h4 id="immermanszelepcsényi-定理"><a class="markdownIt-Anchor" href="#immermanszelepcsényi-定理"></a> Immerman–Szelepcsényi 定理</h4>
<blockquote>
<p><strong>Immerman–Szelepcsényi 定理</strong>. 对于所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>≥</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">s(n) \geq \log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><mo>(</mo><mi>s</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">c</mi><mi mathvariant="sans-serif">o</mi><mtext mathvariant="sans-serif">-</mtext><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><mo>(</mo><mi>s</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">{\sf NSPACE}(s(n)) = {\sf co\text{-}NSPACE}(s(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">c</span><span class="mord mathsf">o</span><span class="mord text"><span class="mord mathsf">-</span></span><span class="mord mathsf">N</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span><span class="mopen">(</span><span class="mord mathit">s</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 都成立.</p>
</blockquote>
<p>接下来简单说一下 Immerman–Szelepcsényi 定理的证明. 也就是说, 给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 个顶点的有向图, 以及一对顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span></span></span></span>, 如何设计一个 NL 算法判定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">s,t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="base"><span class="mord mathit">s</span><span class="mpunct">,</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord mathit">t</span></span></span></span> 之间没有任何连通路径. 我们可以先把问题简化一下, 再要求输入中给出从顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> 出发能到达的顶点个数, 那么我们可以用 NL 算法来验证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> 能到达哪些顶点:</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> 能到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.61508em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">t</span></span></span></span> , 直接拒绝;</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> 能到达的顶点个数跟 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">c</span></span></span></span> 不一样, 直接拒绝; 否则接受.</li>
</ul>
<p>顶点个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">c</span></span></span></span> 也可以用一个 NL 算法得到. 考虑顶点集合 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, 即从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">s</span></span></span></span> 出发, 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.65952em;"></span><span class="strut bottom" style="height:0.65952em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">i</span></span></span></span> 步内能到达的顶点的集合. 那么我们不难由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> 计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"></span></span></span></span></span></span></span></span>; 于是走了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span> 步之后得到的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> 中顶点个数就是我们想要的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">c</span></span></span></span>.</p>
<h2 id="当空间复杂性遇上线性方程组"><a class="markdownIt-Anchor" href="#当空间复杂性遇上线性方程组"></a> 当空间复杂性遇上线性方程组</h2>
<p>另外一个重要的问题, 则是确定性的对数空间和非确定性的对数空间的计算能力是否相同, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">L</mi></mrow></mrow><msup><mo><mo>=</mo></mo><mo>?</mo></msup><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf L} \overset{?}{=} {\sf NL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.152978em;"></span><span class="strut bottom" style="height:1.152978em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.152978em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">=</span></span></span><span style="top:-3.5668699999999998em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mclose mtight">?</span></span></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span></span>. 一个常见的切入点是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.58333em;"></span><span class="strut bottom" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="base"><span class="mord mathit">n</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mord mathit">n</span></span></span></span> 的整数矩阵的行列式 (determinant), 可以证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">N</mi><msup><mi mathvariant="sans-serif">C</mi><mn mathvariant="sans-serif">1</mn></msup></mrow></mrow><mo>⊆</mo><mrow><mrow><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>⊆</mo><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>⊆</mo><mrow><mrow><mi mathvariant="sans-serif">D</mi><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">T</mi></mrow></mrow><mo>⊆</mo><mrow><mrow><mi mathvariant="sans-serif">N</mi><msup><mi mathvariant="sans-serif">C</mi><mn mathvariant="sans-serif">2</mn></msup></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf NC^1} \subseteq {\sf L} \subseteq {\sf NL} \subseteq {\sf DET} \subseteq {\sf NC^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.821892em;"></span><span class="strut bottom" style="height:0.957862em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord"><span class="mord mathsf">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathsf mtight">1</span></span></span></span></span></span></span></span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">D</span><span class="mord mathsf">E</span><span class="mord mathsf">T</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord"><span class="mord mathsf">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathsf mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span>, 计算行列式需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>log</mi><mo>⁡</mo><mn>2</mn></msup><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log^2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8984479999999999em;"></span><span class="strut bottom" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 的空间. 如果我们可以找到一个只需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 空间的算法, 来计算整数行列式的话, 那么可以证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">D</mi><mi mathvariant="sans-serif">E</mi><mi mathvariant="sans-serif">T</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf L} = {\sf NL} = {\sf DET}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">D</span><span class="mord mathsf">E</span><span class="mord mathsf">T</span></span></span></span></span></span>.</p>
<h4 id="hhl-算法在量子空间复杂性中的应用"><a class="markdownIt-Anchor" href="#hhl-算法在量子空间复杂性中的应用"></a> HHL 算法在量子空间复杂性中的应用</h4>
<p>有趣的是, 尽管我们现在仍然不知道如何证明这一结果. 但是如果我们考虑这一问题的量子对应的话, 比如定义类似 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">L</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf L}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">L</span></span></span></span></span></span> 的对数空间的量子复杂性类 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">B</mi><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf BQL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">B</span><span class="mord mathsf">Q</span><span class="mord mathsf">L</span></span></span></span></span></span>, Amnon Ta-Shma  2013 年在 HHL 算法的基础上, 给出了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo>+</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>κ</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log(n)+\log(\kappa))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mord rule" style="margin-right:0.2222222222222222em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">κ</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 空间的厄米矩阵求逆算法 <sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base"><span class="mord mathit">κ</span></span></span></span> 是矩阵的条件数 – 也就是说整数行列式计算有对数空间的量子算法!</p>
<p>Fefferman-Lin 后来在 2016 年证明了这一问题是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">B</mi><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf BQL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.81944em;vertical-align:-0.125em;"></span><span class="base"><span class="mord"><span class="mord mathsf">B</span><span class="mord mathsf">Q</span><span class="mord mathsf">L</span></span></span></span></span>-complete <sup class="footnote-ref"><a href="#fn5" id="fnref5:1">[5:1]</a></sup>, 并且如果我们定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span> 的量子对应 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><msub><mi mathvariant="sans-serif">A</mi><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">O</mi><mi mathvariant="sans-serif">G</mi></mrow></msub></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf QMA_{LOG}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord"><span class="mord mathsf">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathsf mtight">L</span><span class="mord mathsf mtight">O</span><span class="mord mathsf mtight">G</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span></span></span> 的话, 甚至可以证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">B</mi><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">Q</mi><mi mathvariant="sans-serif">M</mi><msub><mi mathvariant="sans-serif">A</mi><mrow><mi mathvariant="sans-serif">L</mi><mi mathvariant="sans-serif">O</mi><mi mathvariant="sans-serif">G</mi></mrow></msub></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf BQL} = {\sf QMA_{LOG}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">B</span><span class="mord mathsf">Q</span><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">Q</span><span class="mord mathsf">M</span><span class="mord"><span class="mord mathsf">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathsf mtight">L</span><span class="mord mathsf mtight">O</span><span class="mord mathsf mtight">G</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span></span></span> <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>. 既然 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">L</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow><annotation encoding="application/x-tex">\sf NL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span> 的量子对应是相等的, 那么也许我们可以证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf L} = {\sf NL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span></span>? 一个可能的途径是借助今年发展的 block-encoding 等一系列技术, 在此基础上对量子对数空间算法做&quot;退量子化&quot; (dequantization), 那么我们会可能得到低秩 (low-rank) 情形下的随机对数空间算法.</p>
<h4 id="我们能证明-lnl-吗"><a class="markdownIt-Anchor" href="#我们能证明-lnl-吗"></a> 我们能证明 L=NL 吗?</h4>
<p>Boix-Adserà, Eldar 和 Mehraban 在最近给出了这一问题的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>κ</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log(n)\log(\kappa))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">κ</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 空间的经典算法 <sup class="footnote-ref"><a href="#fn4" id="fnref4:1">[4:1]</a></sup>, 即在条件数为常数的时候对数空间是足够的, 即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>κ</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log(n)\log(\kappa))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathit">κ</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 空间的经典确定性算法, 对这一结果的进一部分改进可能会证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">L</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">L</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf L}={\sf NL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">L</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">L</span></span></span></span></span></span>. 他们使用的主要技术之一是 Barvinok 在三年前给出的复多项式插值算法, 这一技术也在积和式 (permanent) 的近似算法中非常重要, 并且和量子计算优越性中的 Boson Sampling 有着很深的联系.</p>
<p>我们不难证明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mrow><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow><mo>=</mo><mrow><mrow><mi mathvariant="sans-serif">N</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">S</mi><mi mathvariant="sans-serif">P</mi><mi mathvariant="sans-serif">A</mi><mi mathvariant="sans-serif">C</mi><mi mathvariant="sans-serif">E</mi></mrow></mrow></mrow><annotation encoding="application/x-tex">{\sf PSPACE}={\sf NPSPACE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord"><span class="mord mathsf">N</span><span class="mord mathsf">P</span><span class="mord mathsf">S</span><span class="mord mathsf">P</span><span class="mord mathsf">A</span><span class="mord mathsf">C</span><span class="mord mathsf">E</span></span></span></span></span></span>, 因为多项式的多项式仍然是多项式. 但是对数的多项式仅仅是对数多项式, 为了改进到对数, 我们往往需要做一些很复杂的事情 – 譬如经典 PCP 定理中的通信代价, 直接用 low-degree test 把基于 sum-check protocol 的 NEXP=MIP 的证明做 down-scaling, 那么我们可以把多方交互式证明的通信代价从多项式降到对数多项式, 但是更进一步就需要更复杂的技术 (composition). 我们能对对数空间做同样的事情吗? 现在还不得而知.</p>
<h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>Gopalan, Parikshit, Phokion G. Kolaitis, Elitza Maneva, and Christos H. Papadimitriou. &quot;The connectivity of Boolean satisfiability: computational and structural dichotomies.&quot;<em>SIAM Journal on Computing&quot;</em> 38, no. 6 (2009): 2330-2355. <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Gharibian, Sevag, and Jamie Sikora. “Ground state connectivity of local Hamiltonians.”*ACM Transactions on Computation Theory (TOCT)*10, no. 2 (2018): 8. <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Ta-Shma, Amnon. “Inverting well-conditioned matrices in quantum logspace.” In<em>Proceedings of the forty-fifth annual ACM symposium on Theory of computing</em>, pp. 881-890. ACM, 2013. <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>Enric Boix-Adserà, Lior Eldar, Saeed Mehraban: “Approximating the Determinant of Well-Conditioned Matrices by Shallow Circuits”, 2019; <a href="http://arxiv.org/abs/1912.03824" target="_blank" rel="noopener">arXiv:1912.03824</a>. <a href="#fnref4" class="footnote-backref">↩︎</a> <a href="#fnref4:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>Fefferman, Bill, and Cedric Yen-Yu Lin. “A Complete Characterization of Unitary Quantum Space.” In <em>9th Innovations in Theoretical Computer Science Conference (ITCS 2018)</em>. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2018. <a href="#fnref5" class="footnote-backref">↩︎</a> <a href="#fnref5:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>Fefferman, Bill, Hirotada Kobayashi, Cedric Yen-Yu Lin, Tomoyuki Morimae, and Harumichi Nishimura. “Space-Efficient Error Reduction for Unitary Quantum Computations.” In<em>43rd International Colloquium on Automata, Languages, and Programming (ICALP 2016)</em>. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2016. <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://climberpi.github.io">Climber.pI</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://climberpi.github.io/2020/01/19/space-complexity-meets-determinant/">http://climberpi.github.io/2020/01/19/space-complexity-meets-determinant/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/理论计算机科学/">理论计算机科学</a>
            
              <a href="/tags/量子计算理论/">量子计算理论</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2020/01/21/ETH-atypical-applications/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">(强)指数时间假设非典型应用两则</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2020/01/17/MIP*-eq-RE/">
        <span class="next-text nav-default">一份关于 MIP*=RE 的不太长的介绍</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNTE4NS8xMTcyMA">
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>  
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:yupan.liu@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.zhihu.com/people/climberpi" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2018 - 
    
    2022

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Climber.pI</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  
   <script type="text/javascript">
	(function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
  </script>




    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>
<link rel="stylesheet" href="/js/src/katex.min.css" integrity="sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei" crossorigin="anonymous"><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  </body>
</html>
